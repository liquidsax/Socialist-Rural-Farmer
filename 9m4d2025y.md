项目结构与代码总览
本文档详细记录了 "Happy Farmers" 项目的当前(2025-9-4)文件结构和所有核心JavaScript文件的完整代码。

文件结构树
/HappyFarmers/
  |- index.html              # 游戏主入口HTML文件
  |- /assets/                # 存放所有图片、音频等静态资源
  |  |- farmland.png
  |  |- letter.png
  |  |- menu.png
  |  |- none.png
  |  |- ripe.png
  |  '- seed.png
  |- /js/                    # 存放主逻辑文件
  |  '- main.js
  '- /scenes/                # 存放所有Phaser场景文件
     |- PreloaderScene.js
     |- MainMenuScene.js
     |- CutsceneScene.js
     |- SavesScene.js
     |- GameScene.js
     '- PauseScene.js

核心文件代码
1. index.html
游戏加载的入口，负责引入Phaser库和我们的主逻辑文件 main.js。

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Happy Farmers</title>
    <!-- 引入 Phaser 库 -->
    <script src="[https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js](https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js)"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #000;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script type="module" src="js/main.js"></script>
</body>
</html>

2. js/main.js
Phaser游戏实例的配置中心。它定义了游戏的尺寸、渲染方式，并注册了项目中所有需要用到的场景。

import { PreloaderScene } from '../scenes/PreloaderScene.js';
import { MainMenuScene } from '../scenes/MainMenuScene.js';
import { CutsceneScene } from '../scenes/CutsceneScene.js';
import { SavesScene } from '../scenes/SavesScene.js';
import { GameScene } from '../scenes/GameScene.js';
import { PauseScene } from '../scenes/PauseScene.js';

const config = {
    type: Phaser.AUTO,
    parent: 'game-container',
    width: 1280,
    height: 720,
    backgroundColor: '#000000',
    scene: [
        PreloaderScene,
        MainMenuScene,
        CutsceneScene,
        SavesScene,
        GameScene,
        PauseScene
    ],
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    },
};

new Phaser.Game(config);

3. scenes/PreloaderScene.js
游戏启动后的第一个场景，负责加载整个游戏所需的所有资源，并显示一个进度条。加载完毕后自动跳转到主菜单。

export class PreloaderScene extends Phaser.Scene {
    constructor() { super('PreloaderScene'); }

    preload() {
        this.add.text(this.sys.game.config.width / 2, this.sys.game.config.height / 2 - 50, '游戏加载中...', { fontSize: '48px', fill: '#ffffff' }).setOrigin(0.5);
        const progressBar = this.add.graphics();
        const progressBox = this.add.graphics();
        progressBox.fillStyle(0x222222, 0.8);
        progressBox.fillRect(this.sys.game.config.width / 2 - 160, this.sys.game.config.height / 2, 320, 50);

        this.load.on('progress', (value) => {
            progressBar.clear();
            progressBar.fillStyle(0xffffff, 1);
            progressBar.fillRect(this.sys.game.config.width / 2 - 150, this.sys.game.config.height / 2 + 10, 300 * value, 30);
        });

        this.load.on('complete', () => {
            progressBar.destroy();
            progressBox.destroy();
        });

        // 加载所有资源
        this.load.image('menu', 'assets/menu.png');
        this.load.image('farm', 'assets/farmland.png');
        this.load.image('letter', 'assets/letter.png');
        this.load.image('plot', 'assets/none.png');
        this.load.image('sprout', 'assets/seed.png');
        this.load.image('carrot', 'assets/ripe.png');
    }

    create() {
        this.scene.start('MainMenuScene');
    }
}

4. scenes/MainMenuScene.js
智能主菜单。它会检查是否存在存档，并动态显示“继续游戏”或“新游戏”。

export class MainMenuScene extends Phaser.Scene {
    constructor() { super('MainMenuScene'); }

    create() {
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        this.add.image(gameWidth / 2, gameHeight / 2, 'menu').setDisplaySize(gameWidth, gameHeight);
        this.add.text(gameWidth / 2, gameHeight / 2 - 150, '社会主义新农村建设', { fontSize: '64px', fill: '#ffffff', stroke: '#000000', strokeThickness: 6 }).setOrigin(0.5);

        const allSaves = this.loadAllSaves();
        const mostRecentSave = this.findMostRecentSave(allSaves);

        let firstButton;
        if (mostRecentSave) {
            firstButton = this.add.text(gameWidth / 2, gameHeight / 2, '继续游戏', { fontSize: '32px', fill: '#FFF', backgroundColor: '#333' }).setOrigin(0.5).setPadding(15).setInteractive();
            firstButton.on('pointerdown', () => {
                this.scene.start('GameScene', { saveSlot: mostRecentSave.slot, loadSave: true });
            });
        } else {
            firstButton = this.add.text(gameWidth / 2, gameHeight / 2, '新游戏', { fontSize: '32px', fill: '#FFF', backgroundColor: '#333' }).setOrigin(0.5).setPadding(15).setInteractive();
            firstButton.on('pointerdown', () => {
                const hasPlayedIntro = localStorage.getItem('hasPlayedIntro') === 'true';
                if (!hasPlayedIntro) {
                    this.scene.start('CutsceneScene');
                } else {
                    this.scene.start('SavesScene');
                }
            });
        }

        const savesButton = this.add.text(gameWidth / 2, gameHeight / 2 + 80, '存档管理', { fontSize: '32px', fill: '#FFF', backgroundColor: '#333' }).setOrigin(0.5).setPadding(15).setInteractive();
        savesButton.on('pointerdown', () => {
            this.scene.start('SavesScene');
        });

        [firstButton, savesButton].forEach(button => {
            button.on('pointerover', () => button.setBackgroundColor('#555'));
            button.on('pointerout', () => button.setBackgroundColor('#333'));
        });
    }
    
    loadAllSaves() {
        const savedData = localStorage.getItem('myFarmAllSlots');
        if (savedData) { return JSON.parse(savedData); }
        return [];
    }

    findMostRecentSave(allSaves) {
        const existingSaves = allSaves.filter(s => s.hasData);
        if (existingSaves.length === 0) return null;
        existingSaves.sort((a, b) => b.lastSave - a.lastSave);
        return existingSaves[0];
    }
}

5. scenes/CutsceneScene.js
开场动画场景，负责展示“领导来信”。

export class CutsceneScene extends Phaser.Scene {
    constructor() { super('CutsceneScene'); }

    create() {
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;

        this.add.rectangle(0, 0, gameWidth, gameHeight, 0x000000, 0.7).setOrigin(0);
        const letter = this.add.image(gameWidth / 2, gameHeight / 2, 'letter');

        const VISIBLE_WIDTH_SCALE = 0.85;
        const padding = 20;
        const wordWrapWidth = (letter.displayWidth * VISIBLE_WIDTH_SCALE) - (padding * 2);

        const textStyle = { fontSize: '28px', fill: '#333333', wordWrap: { width: wordWrapWidth }, lineSpacing: 10, align: 'left' };
        const letterContent = `亲爱的同志：\n\n时代在召唤，乡村正振兴。\n\n鉴于你出色的能力与坚定的信念，组织决定委派你前往一线，负责新农村的建设工作。那里有广阔的天地，等待你去耕耘；有淳朴的人民，期待你的带领。\n\n这不仅是一份工作，更是一份沉甸甸的责任。希望你不负韶华，不负使命，用你的智慧和汗水，在那片土地上书写新的篇章。\n\n期待你的好消息！\n\n你的领导\n2025年9月4日`;
        const text = this.add.text(letter.x, letter.y, letterContent, textStyle).setOrigin(0.5);

        letter.setScale(0);
        text.setAlpha(0);

        this.tweens.add({
            targets: letter, scale: 1, duration: 800, ease: 'Power2',
            onComplete: () => {
                this.tweens.add({
                    targets: text, alpha: 1, duration: 1200, ease: 'Sine.easeIn',
                    onComplete: () => {
                        const continueText = this.add.text(gameWidth / 2, gameHeight - 70, '【点击任意处继续】', { fontSize: '24px', fill: '#FFFFFF' }).setOrigin(0.5).setAlpha(0);
                        this.tweens.add({ targets: continueText, alpha: 1, duration: 700, ease: 'Sine.easeInOut', yoyo: true, loop: -1 });
                        this.input.once('pointerdown', () => { this.cameras.main.fadeOut(1000, 0, 0, 0); });
                    }
                });
            }
        });

        this.cameras.main.once(Phaser.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, () => {
            localStorage.setItem('hasPlayedIntro', 'true');
            this.scene.start('GameScene', { saveSlot: 0, loadSave: false });
        });
    }
}

6. scenes/SavesScene.js
存档管理场景，动态罗列所有存档槽位，供玩家选择加载或开启新游戏。

export class SavesScene extends Phaser.Scene {
    constructor() { super('SavesScene'); }

    create() {
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        this.add.image(gameWidth / 2, gameHeight / 2, 'menu').setDisplaySize(gameWidth, gameHeight);
        this.add.text(gameWidth / 2, gameHeight / 2 - 150, '存档管理', { fontSize: '64px', fill: '#ffffff', stroke: '#000000', strokeThickness: 6 }).setOrigin(0.5);

        const allSaves = this.loadAllSaves();
        allSaves.forEach((saveData, index) => {
            const yPos = gameHeight / 2 - 20 + index * 80;
            let textToShow;
            const hasData = saveData.hasData;
            if (hasData) {
                const saveDate = new Date(saveData.lastSave).toLocaleString();
                textToShow = `存档 ${index + 1} - [${saveDate}]`;
            } else {
                textToShow = `[ 新游戏 - 存档槽 ${index + 1} ]`;
            }
            const slotButton = this.add.text(gameWidth / 2, yPos, textToShow, { fontSize: '28px', fill: '#FFF', backgroundColor: '#333', align: 'center' }).setOrigin(0.5).setPadding(15).setInteractive();
            slotButton.on('pointerdown', () => { this.scene.start('GameScene', { saveSlot: index, loadSave: hasData }); });
            slotButton.on('pointerover', () => slotButton.setBackgroundColor('#555'));
            slotButton.on('pointerout', () => slotButton.setBackgroundColor('#333'));
        });

        const backButton = this.add.text(120, gameHeight - 50, '返回主菜单', { fontSize: '24px', fill: '#FFF' }).setOrigin(0.5).setPadding(10).setInteractive();
        backButton.on('pointerdown', () => { this.scene.start('MainMenuScene'); });
        backButton.on('pointerover', () => backButton.setFill('#FF0'));
        backButton.on('pointerout', () => backButton.setFill('#FFF'));
    }
    
    loadAllSaves() {
        const savedData = localStorage.getItem('myFarmAllSlots');
        if (savedData) { return JSON.parse(savedData); }
        return [
            { slot: 0, hasData: false, lastSave: null },
            { slot: 1, hasData: false, lastSave: null },
            { slot: 2, hasData: false, lastSave: null },
        ];
    }
}

7. scenes/GameScene.js
核心游戏玩法场景。负责处理农场布局、作物生长、收获、多存档的保存与加载，以及响应 ESC 暂停。

export class GameScene extends Phaser.Scene {
    constructor() {
        super('GameScene');
        this.currentSaveSlot = 0;
        this.shouldLoadSave = false;
    }
    
    init(data) {
        if (data && data.saveSlot !== undefined) {
            this.currentSaveSlot = data.saveSlot;
            this.shouldLoadSave = data.loadSave;
        } else {
            this.currentSaveSlot = 0;
            this.shouldLoadSave = false;
        }
    }

    preload() { }

    create() {
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        const bgpic = this.add.image(gameWidth / 2, gameHeight / 2, 'farm');
        bgpic.setDisplaySize(gameWidth, gameHeight);

        this.add.text(640, 50, '点击土地来种植和收获 (按ESC暂停)', { fontSize: '32px', fill: '#ffffff', stroke: '#000000', strokeThickness: 4 }).setOrigin(0.5);
        this.plots = this.loadPlots(this.shouldLoadSave, this.currentSaveSlot);

        const plotSize = 150;
        const spacing = 20;
        const startX = (gameWidth - (this.plots.length * plotSize + (this.plots.length - 1) * spacing)) / 2;
        const startY = gameHeight / 2;

        this.plots.forEach((plotData, i) => {
            const x = startX + i * (plotSize + spacing);
            const y = startY;
            let initialTexture = 'plot';
            if (plotData.isPlanted) {
                if (Date.now() >= plotData.matureTime) {
                    initialTexture = 'carrot';
                    plotData.isMature = true;
                } else { initialTexture = 'sprout'; }
            }
            const plotSprite = this.add.sprite(x, y, initialTexture).setInteractive().setOrigin(0, 0).setDisplaySize(plotSize, plotSize);
            plotData.sprite = plotSprite;
            if (plotData.isPlanted && !plotData.isMature) {
                const remainingTime = plotData.matureTime - Date.now();
                if (remainingTime > 0) {
                    this.time.delayedCall(remainingTime, () => { this.matureCrop(plotData); });
                }
            }
            plotSprite.on('pointerdown', () => { this.onPlotClicked(plotData); });
        });

        this.coordsText = this.add.text(10, 10, 'X: 0, Y: 0', { fontSize: '16px', fill: '#ffffff', backgroundColor: '#000000' });
        this.input.keyboard.on('keydown-ESC', () => {
            this.savePlots(this.currentSaveSlot);
            this.scene.pause();
            this.scene.launch('PauseScene');
        });
    }

    onPlotClicked(plotData) {
        if (!plotData.isPlanted) {
            plotData.isPlanted = true;
            plotData.sprite.setTexture('sprout');
            const growthTime = 3000;
            plotData.matureTime = Date.now() + growthTime;
            this.time.delayedCall(growthTime, () => { this.matureCrop(plotData); });
        } else if (plotData.isMature) {
            plotData.sprite.setTexture('plot');
            plotData.isPlanted = false;
            plotData.isMature = false;
            plotData.matureTime = 0;
        }
        this.savePlots(this.currentSaveSlot);
    }

    matureCrop(plotData) {
        if (!plotData.isMature) {
            plotData.isMature = true;
            plotData.sprite.setTexture('carrot');
            this.savePlots(this.currentSaveSlot);
        }
    }

    savePlots(slotIndex) {
        if (slotIndex === undefined) return;
        const allSaves = this.loadAllSaves();
        allSaves[slotIndex] = {
            slot: slotIndex, hasData: true, lastSave: new Date().getTime(),
            plots: this.plots.map(p => ({ id: p.id, isPlanted: p.isPlanted, isMature: p.isMature, matureTime: p.matureTime }))
        };
        localStorage.setItem('myFarmAllSlots', JSON.stringify(allSaves));
        console.log(`游戏进度已保存到存档槽 ${slotIndex}!`);
    }

    loadPlots(shouldLoad, slotIndex) {
        const allSaves = this.loadAllSaves();
        const saveData = allSaves[slotIndex];
        if (shouldLoad && saveData && saveData.hasData) {
            return saveData.plots;
        }
        const numPlots = 5;
        let newPlots = [];
        for (let i = 0; i < numPlots; i++) { newPlots.push({ id: i, isPlanted: false, isMature: false, matureTime: 0, sprite: null }); }
        return newPlots;
    }

    loadAllSaves() {
        const savedData = localStorage.getItem('myFarmAllSlots');
        try {
            if (savedData) { return JSON.parse(savedData); }
        } catch (e) { console.error("解析存档失败", e); }
        return [
            { slot: 0, hasData: false, lastSave: null, plots: null },
            { slot: 1, hasData: false, lastSave: null, plots: null },
            { slot: 2, hasData: false, lastSave: null, plots: null },
        ];
    }

    update() {
        if (this.coordsText) {
            const pointer = this.input.activePointer;
            this.coordsText.setText(['X: ' + pointer.x.toFixed(2), 'Y: ' + pointer.y.toFixed(2)]);
        }
    }
}

8. scenes/PauseScene.js
游戏内的暂停菜单场景，在 GameScene 上方叠加显示。

export class PauseScene extends Phaser.Scene {
    constructor() { super('PauseScene'); }

    create() {
        this.add.rectangle(0, 0, this.sys.game.config.width, this.sys.game.config.height, 0x000000, 0.7).setOrigin(0);
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;

        this.add.text(gameWidth / 2, gameHeight / 2 - 100, '游戏已暂停', { fontSize: '48px', fill: '#ffffff' }).setOrigin(0.5);
        const resumeButton = this.add.text(gameWidth / 2, gameHeight / 2, '继续游戏', { fontSize: '32px', fill: '#FFF', backgroundColor: '#333' }).setOrigin(0.5).setPadding(15).setInteractive();
        const saveAndExitButton = this.add.text(gameWidth / 2, gameHeight / 2 + 80, '保存并返回主菜单', { fontSize: '32px', fill: '#FFF', backgroundColor: '#333' }).setOrigin(0.5).setPadding(15).setInteractive();

        resumeButton.on('pointerdown', () => {
            this.scene.stop();
            this.scene.resume('GameScene');
        });

        saveAndExitButton.on('pointerdown', () => {
            this.scene.stop('GameScene');
            this.scene.stop('PauseScene');
            this.scene.start('MainMenuScene');
        });

        [resumeButton, saveAndExitButton].forEach(button => {
            button.on('pointerover', () => button.setBackgroundColor('#555'));
            button.on('pointerout', () => button.setBackgroundColor('#333'));
        });
    }
}
